<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mandelbrot WebGL — Zoom ultra rápido</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    canvas { width: 100vw; height: 100vh; display: block; }
    .hud {
      position: fixed; left: 12px; top: 12px; padding: 8px 10px;
      background: rgba(0,0,0,.45); color: #eaeaea; font: 12px/1.3 ui-monospace, monospace;
      border: 1px solid rgba(255,255,255,.12); border-radius: 10px; user-select: none;
      backdrop-filter: blur(4px);
    }
    .hud b { color: #fff; }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>
  <div class="hud" id="hud">
    <div><b>Rueda del mouse:</b> Zoom | <b>Arrastrar:</b> Pan</div>
    <div id="stats"></div>
  </div>

  <!-- Vertex shader -->
  <script id="vs" type="x-shader/x-vertex">
  attribute vec2 a_pos;
  void main() {
    gl_Position = vec4(a_pos, 0.0, 1.0);
  }
  </script>

  <!-- Fragment shader (WebGL1, alta precisión) -->
  <script id="fs" type="x-shader/x-fragment">
  precision highp float;

  uniform vec2 u_resolution;   // tamaño en px
  uniform vec2 u_center;       // centro en el plano complejo
  uniform float u_scale;       // escala (alto del plano complejo)
  uniform float u_aspect;      // relación ancho/alto
  uniform int u_maxIter;       // iteraciones
  uniform float u_smooth;      // suavizado de color

  // Conversión HSV -> RGB simple para paleta suave
  vec3 hsv2rgb(vec3 c){
    vec3 p = abs(fract(c.xxx + vec3(0., 2./3., 1./3.)) * 6. - 3.);
    return c.z * mix(vec3(1.), clamp(p - 1., 0., 1.), c.y);
  }

  void main() {
    // Coordenada en píxeles
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution);
    // Escalar por altura para mantener proporción
    vec2 z0 = vec2(
      u_center.x + (uv.x / (0.5 * u_resolution.y)) * (u_scale * 0.5) * u_aspect,
      u_center.y + (uv.y / (0.5 * u_resolution.y)) * (u_scale * 0.5)
    );

    // Iteración Mandelbrot
    float zr = 0.0, zi = 0.0;
    float zr2 = 0.0, zi2 = 0.0;
    int i;
    for (i = 0; i < 4096; i++) { // límite duro
      if (i >= u_maxIter) break;
      zi = (zr + zr) * zi + z0.y;  // 2*zr*zi + cy
      zr = zr2 - zi2 + z0.x;       // zr^2 - zi^2 + cx
      zr2 = zr*zr;
      zi2 = zi*zi;
      if (zr2 + zi2 > 4.0) break;
    }

    // Coloración suave (normalized iteration count)
    float n = float(i);
    float shade;
    if (i >= u_maxIter) {
      // Dentro del conjunto: negro profundo con leve tinte
      shade = 0.0;
      gl_FragColor = vec4(0.02, 0.02, 0.03, 1.0);
      return;
    } else {
      // Suavizado clásico: n + 1 - log2(log2(|z|))
      float mag = sqrt(zr2 + zi2);
      float nu = log2(log2(mag)) * 0.5;
      shade = (n + 1.0 - nu) / float(u_maxIter);
    }

    // Paleta: rotación en tono y contraste con u_smooth
    float hue = fract(0.95 - 0.75 * shade);
    float sat = 0.85;
    float val = pow(shade, u_smooth) * 1.2;
    vec3 col = hsv2rgb(vec3(hue, sat, val));

    gl_FragColor = vec4(col, 1.0);
  }
  </script>

  <script src="app.js"></script>
</body>
</html>
